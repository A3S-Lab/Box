//! gRPC client and server for host-guest communication

use a3s_box_core::error::{BoxError, Result};
use crate::session::{GenerateResult, TokenUsage};
use serde::{Deserialize, Serialize};

/// gRPC client for communicating with guest agent
pub struct AgentClient {
    // TODO: Add tonic gRPC client
    _placeholder: (),
}

impl AgentClient {
    /// Create a new agent client
    pub fn new(_vsock_port: u32) -> Self {
        // TODO: Connect to guest agent via vsock
        Self {
            _placeholder: (),
        }
    }

    /// Create a session
    pub async fn create_session(&self, _config: CreateSessionRequest) -> Result<CreateSessionResponse> {
        // TODO: Implement gRPC call
        Err(BoxError::Other("Not implemented".to_string()))
    }

    /// Destroy a session
    pub async fn destroy_session(&self, _session_id: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Generate (non-streaming)
    pub async fn generate(&self, _request: GenerateRequest) -> Result<GenerateResult> {
        // TODO: Implement gRPC call
        Err(BoxError::Other("Not implemented".to_string()))
    }

    /// Stream (streaming response)
    pub async fn stream(&self, _request: GenerateRequest) -> Result<GenerateStream> {
        // TODO: Implement gRPC streaming call
        Err(BoxError::Other("Not implemented".to_string()))
    }

    /// Generate object (structured output)
    pub async fn generate_object(&self, _request: GenerateObjectRequest) -> Result<GenerateObjectResult> {
        // TODO: Implement gRPC call
        Err(BoxError::Other("Not implemented".to_string()))
    }

    /// Use skill
    pub async fn use_skill(&self, _session_id: &str, _skill_name: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Remove skill
    pub async fn remove_skill(&self, _session_id: &str, _skill_name: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Compact context
    pub async fn compact(&self, _session_id: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Clear context
    pub async fn clear(&self, _session_id: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Get context usage
    pub async fn context_usage(&self, _session_id: &str) -> Result<ContextUsageResponse> {
        // TODO: Implement gRPC call
        Err(BoxError::Other("Not implemented".to_string()))
    }

    /// Cancel active prompt
    pub async fn cancel(&self, _session_id: &str) -> Result<()> {
        // TODO: Implement gRPC call
        Ok(())
    }

    /// Health check
    pub async fn health_check(&self) -> Result<bool> {
        // TODO: Implement gRPC health check
        Ok(true)
    }
}

/// Create session request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSessionRequest {
    pub system: Option<String>,
    pub context_threshold: f32,
    pub context_strategy: String,
}

/// Create session response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSessionResponse {
    pub session_id: String,
}

/// Generate request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateRequest {
    pub session_id: String,
    pub prompt: String,
}

/// Generate object request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateObjectRequest {
    pub session_id: String,
    pub prompt: String,
    pub schema: serde_json::Value,
}

/// Generate object result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateObjectResult {
    pub object: serde_json::Value,
    pub usage: TokenUsage,
}

/// Context usage response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextUsageResponse {
    pub used_tokens: usize,
    pub max_tokens: usize,
    pub percent: f32,
    pub turns: usize,
}

/// Generate stream (placeholder)
pub struct GenerateStream {
    // TODO: Implement streaming response
    _placeholder: (),
}

impl GenerateStream {
    /// Receive next chunk
    pub async fn recv(&mut self) -> Option<StreamChunk> {
        // TODO: Implement
        None
    }
}

/// Stream chunk
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StreamChunk {
    TextDelta(String),
    ToolCall { name: String, args: serde_json::Value },
    ToolResult { name: String, output: String },
    Done(GenerateResult),
}

/// Protobuf definitions directory
pub mod proto {
    // TODO: Generated protobuf code will go here
    // This will be generated by tonic-build in build.rs
}

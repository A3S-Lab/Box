//! gRPC client for host-guest communication over Unix socket.

use std::path::{Path, PathBuf};

use a3s_box_core::error::{BoxError, Result};
use serde::{Deserialize, Serialize};
use tokio::net::UnixStream;
use tokio::sync::Mutex;
use tonic::transport::{Channel, Endpoint, Uri};
use tower::service_fn;

use crate::session::{GenerateResult, TokenUsage};

/// Generated protobuf definitions for the agent service.
pub mod proto {
    // The file is generated by tonic-build from agent.proto
    include!("grpc/proto/a3s.r#box.agent.rs");
}

/// Wrapper to implement the required hyper `Connection` trait on `UnixStream`.
#[derive(Debug)]
struct UnixStreamWrapper(pub UnixStream);

impl tokio::io::AsyncRead for UnixStreamWrapper {
    fn poll_read(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &mut tokio::io::ReadBuf<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        std::pin::Pin::new(&mut self.0).poll_read(cx, buf)
    }
}

impl tokio::io::AsyncWrite for UnixStreamWrapper {
    fn poll_write(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &[u8],
    ) -> std::task::Poll<std::io::Result<usize>> {
        std::pin::Pin::new(&mut self.0).poll_write(cx, buf)
    }

    fn poll_flush(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        std::pin::Pin::new(&mut self.0).poll_flush(cx)
    }

    fn poll_shutdown(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        std::pin::Pin::new(&mut self.0).poll_shutdown(cx)
    }
}

impl hyper::client::connect::Connection for UnixStreamWrapper {
    fn connected(&self) -> hyper::client::connect::Connected {
        hyper::client::connect::Connected::new()
    }
}

/// gRPC client for communicating with guest agent over Unix socket.
pub struct AgentClient {
    socket_path: PathBuf,
    inner: Mutex<proto::agent_service_client::AgentServiceClient<Channel>>,
}

impl AgentClient {
    /// Connect to the guest agent via Unix socket.
    pub async fn connect(socket_path: &Path) -> Result<Self> {
        let socket_path_owned = socket_path.to_path_buf();
        let socket_path_for_connect = socket_path_owned.clone();

        // tonic requires a valid URI, but we override the connector to use Unix socket.
        // The actual URI is ignored by our custom connector.
        let channel = Endpoint::try_from("http://[::]:50051")
            .map_err(|e| BoxError::Other(format!("Failed to create endpoint: {}", e)))?
            .connect_timeout(std::time::Duration::from_secs(5))
            .timeout(std::time::Duration::from_secs(300))
            .connect_with_connector(service_fn(move |_: Uri| {
                let path = socket_path_for_connect.clone();
                async move {
                    let stream = UnixStream::connect(path).await?;
                    Ok::<_, std::io::Error>(UnixStreamWrapper(stream))
                }
            }))
            .await
            .map_err(|e| BoxError::Other(format!(
                "Failed to connect to agent at {}: {}",
                socket_path_owned.display(),
                e,
            )))?;

        let client = proto::agent_service_client::AgentServiceClient::new(channel);

        Ok(Self {
            socket_path: socket_path.to_path_buf(),
            inner: Mutex::new(client),
        })
    }

    /// Get the socket path this client is connected to.
    pub fn socket_path(&self) -> &Path {
        &self.socket_path
    }

    /// Create a session on the guest agent.
    pub async fn create_session(
        &self,
        config: CreateSessionRequest,
    ) -> Result<CreateSessionResponse> {
        let request = proto::CreateSessionRequest {
            system: config.system,
            context_threshold: config.context_threshold,
            context_strategy: config.context_strategy,
        };

        let response = self
            .inner
            .lock()
            .await
            .create_session(request)
            .await?
            .into_inner();

        Ok(CreateSessionResponse {
            session_id: response.session_id,
        })
    }

    /// Destroy a session.
    pub async fn destroy_session(&self, session_id: &str) -> Result<()> {
        let request = proto::DestroySessionRequest {
            session_id: session_id.to_string(),
        };

        self.inner.lock().await.destroy_session(request).await?;
        Ok(())
    }

    /// Generate (non-streaming).
    pub async fn generate(&self, request: GenerateRequest) -> Result<GenerateResult> {
        let proto_request = proto::GenerateRequest {
            session_id: request.session_id,
            prompt: request.prompt,
        };

        let response = self
            .inner
            .lock()
            .await
            .generate(proto_request)
            .await?
            .into_inner();

        Ok(proto_generate_response_to_result(response))
    }

    /// Stream (streaming response).
    pub async fn stream(&self, request: GenerateRequest) -> Result<GenerateStream> {
        let proto_request = proto::GenerateRequest {
            session_id: request.session_id,
            prompt: request.prompt,
        };

        let response = self
            .inner
            .lock()
            .await
            .stream(proto_request)
            .await?
            .into_inner();

        Ok(GenerateStream { inner: response })
    }

    /// Generate structured output (object).
    pub async fn generate_object(
        &self,
        request: GenerateObjectRequest,
    ) -> Result<GenerateObjectResult> {
        let proto_request = proto::GenerateObjectRequest {
            session_id: request.session_id,
            prompt: request.prompt,
            schema: serde_json::to_string(&request.schema).map_err(|e| {
                BoxError::SerializationError(format!("Failed to serialize schema: {}", e))
            })?,
        };

        let response = self
            .inner
            .lock()
            .await
            .generate_object(proto_request)
            .await?
            .into_inner();

        let object: serde_json::Value =
            serde_json::from_str(&response.object).unwrap_or(serde_json::Value::Null);

        let usage = response.usage.map(proto_token_usage_to_domain).unwrap_or(
            TokenUsage {
                prompt_tokens: 0,
                completion_tokens: 0,
                total_tokens: 0,
            },
        );

        Ok(GenerateObjectResult { object, usage })
    }

    /// Use a skill in a session.
    pub async fn use_skill(&self, session_id: &str, skill_name: &str) -> Result<()> {
        let request = proto::UseSkillRequest {
            session_id: session_id.to_string(),
            skill_name: skill_name.to_string(),
        };

        self.inner.lock().await.use_skill(request).await?;
        Ok(())
    }

    /// Remove a skill from a session.
    pub async fn remove_skill(&self, session_id: &str, skill_name: &str) -> Result<()> {
        let request = proto::RemoveSkillRequest {
            session_id: session_id.to_string(),
            skill_name: skill_name.to_string(),
        };

        self.inner.lock().await.remove_skill(request).await?;
        Ok(())
    }

    /// Compact session context.
    pub async fn compact(&self, session_id: &str) -> Result<()> {
        let request = proto::SessionCommandRequest {
            session_id: session_id.to_string(),
        };

        self.inner.lock().await.compact(request).await?;
        Ok(())
    }

    /// Clear session context.
    pub async fn clear(&self, session_id: &str) -> Result<()> {
        let request = proto::SessionCommandRequest {
            session_id: session_id.to_string(),
        };

        self.inner.lock().await.clear(request).await?;
        Ok(())
    }

    /// Configure a session (thinking mode, budget, model).
    pub async fn configure(&self, request: ConfigureRequest) -> Result<()> {
        let proto_request = proto::ConfigureRequest {
            session_id: request.session_id,
            thinking: request.thinking,
            budget: request.budget,
            model: request.model.map(|m| proto::ModelConfig {
                provider: m.provider,
                name: m.name,
                base_url: m.base_url,
                api_key: m.api_key,
            }),
        };

        self.inner.lock().await.configure(proto_request).await?;
        Ok(())
    }

    /// Get context usage for a session.
    pub async fn context_usage(&self, session_id: &str) -> Result<ContextUsageResponse> {
        let request = proto::ContextUsageRequest {
            session_id: session_id.to_string(),
        };

        let response = self
            .inner
            .lock()
            .await
            .get_context_usage(request)
            .await?
            .into_inner();

        Ok(ContextUsageResponse {
            used_tokens: response.used_tokens as usize,
            max_tokens: response.max_tokens as usize,
            percent: response.percent,
            turns: response.turns as usize,
        })
    }

    /// Get conversation history for a session.
    pub async fn get_history(&self, session_id: &str) -> Result<Vec<HistoryTurn>> {
        let request = proto::HistoryRequest {
            session_id: session_id.to_string(),
        };

        let response = self
            .inner
            .lock()
            .await
            .get_history(request)
            .await?
            .into_inner();

        let turns = response
            .turns
            .into_iter()
            .map(|t| HistoryTurn {
                role: t.role,
                content: t.content,
                timestamp: t.timestamp,
            })
            .collect();

        Ok(turns)
    }

    /// Cancel the active prompt in a session.
    pub async fn cancel(&self, session_id: &str) -> Result<()> {
        let request = proto::CancelRequest {
            session_id: session_id.to_string(),
        };

        self.inner.lock().await.cancel(request).await?;
        Ok(())
    }

    /// Perform a health check on the guest agent.
    pub async fn health_check(&self) -> Result<bool> {
        let request = proto::HealthCheckRequest {};

        let response = self
            .inner
            .lock()
            .await
            .health_check(request)
            .await?
            .into_inner();

        Ok(response.healthy)
    }
}

// ── Domain types ──────────────────────────────────────────────────

/// Create session request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSessionRequest {
    pub system: Option<String>,
    pub context_threshold: f32,
    pub context_strategy: String,
}

/// Create session response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSessionResponse {
    pub session_id: String,
}

/// Generate request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateRequest {
    pub session_id: String,
    pub prompt: String,
}

/// Generate object request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateObjectRequest {
    pub session_id: String,
    pub prompt: String,
    pub schema: serde_json::Value,
}

/// Generate object result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateObjectResult {
    pub object: serde_json::Value,
    pub usage: TokenUsage,
}

/// Configure request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfigureRequest {
    pub session_id: String,
    pub thinking: Option<bool>,
    pub budget: Option<i32>,
    pub model: Option<ModelConfig>,
}

/// Model configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelConfig {
    pub provider: String,
    pub name: String,
    pub base_url: Option<String>,
    pub api_key: Option<String>,
}

/// Context usage response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextUsageResponse {
    pub used_tokens: usize,
    pub max_tokens: usize,
    pub percent: f32,
    pub turns: usize,
}

/// Conversation history turn.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryTurn {
    pub role: String,
    pub content: String,
    pub timestamp: i64,
}

/// Streaming response wrapper for Generate RPC.
pub struct GenerateStream {
    inner: tonic::Streaming<proto::StreamChunk>,
}

impl GenerateStream {
    /// Receive the next chunk from the stream.
    pub async fn recv(&mut self) -> Option<StreamChunk> {
        match self.inner.message().await {
            Ok(Some(proto_chunk)) => proto_stream_chunk_to_domain(proto_chunk),
            Ok(None) => None,
            Err(e) => {
                tracing::warn!(error = %e, "Stream error");
                None
            }
        }
    }
}

/// Stream chunk variants.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StreamChunk {
    TextDelta(String),
    ToolCall {
        name: String,
        args: serde_json::Value,
    },
    ToolResult {
        name: String,
        output: String,
    },
    Done(GenerateResult),
}

// ── Proto ↔ Domain conversions ──────────────────────────────────

fn proto_token_usage_to_domain(usage: proto::TokenUsage) -> TokenUsage {
    TokenUsage {
        prompt_tokens: usage.prompt_tokens as usize,
        completion_tokens: usage.completion_tokens as usize,
        total_tokens: usage.total_tokens as usize,
    }
}

fn proto_tool_call_to_domain(tc: proto::ToolCall) -> crate::session::ToolCall {
    crate::session::ToolCall {
        name: tc.name,
        args: serde_json::from_str(&tc.args).unwrap_or(serde_json::Value::Null),
    }
}

fn proto_tool_result_to_domain(tr: proto::ToolResult) -> crate::session::ToolResult {
    crate::session::ToolResult {
        name: tr.name,
        output: tr.output,
        exit_code: tr.exit_code,
    }
}

fn proto_step_to_domain(step: proto::Step) -> crate::session::Step {
    let step_type = match step.step_type.as_str() {
        "thinking" => crate::session::StepType::Thinking,
        "tool_call" => crate::session::StepType::ToolCall,
        _ => crate::session::StepType::Text,
    };

    crate::session::Step {
        index: step.index as usize,
        step_type,
        content: step.content,
    }
}

fn proto_generate_response_to_result(response: proto::GenerateResponse) -> GenerateResult {
    let usage = response.usage.map(proto_token_usage_to_domain).unwrap_or(
        TokenUsage {
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0,
        },
    );

    GenerateResult {
        text: response.text,
        usage,
        tool_calls: response.tool_calls.into_iter().map(proto_tool_call_to_domain).collect(),
        tool_results: response
            .tool_results
            .into_iter()
            .map(proto_tool_result_to_domain)
            .collect(),
        steps: response.steps.into_iter().map(proto_step_to_domain).collect(),
    }
}

fn proto_stream_chunk_to_domain(chunk: proto::StreamChunk) -> Option<StreamChunk> {
    match chunk.chunk? {
        proto::stream_chunk::Chunk::TextDelta(text) => Some(StreamChunk::TextDelta(text)),
        proto::stream_chunk::Chunk::ToolCall(tc) => Some(StreamChunk::ToolCall {
            name: tc.name,
            args: serde_json::from_str(&tc.args).unwrap_or(serde_json::Value::Null),
        }),
        proto::stream_chunk::Chunk::ToolResult(tr) => Some(StreamChunk::ToolResult {
            name: tr.name,
            output: tr.output,
        }),
        proto::stream_chunk::Chunk::Done(response) => {
            Some(StreamChunk::Done(proto_generate_response_to_result(response)))
        }
    }
}

// ── Tests ────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proto_token_usage_to_domain() {
        let proto_usage = proto::TokenUsage {
            prompt_tokens: 100,
            completion_tokens: 50,
            total_tokens: 150,
        };

        let domain = proto_token_usage_to_domain(proto_usage);
        assert_eq!(domain.prompt_tokens, 100);
        assert_eq!(domain.completion_tokens, 50);
        assert_eq!(domain.total_tokens, 150);
    }

    #[test]
    fn test_proto_tool_call_to_domain() {
        let proto_tc = proto::ToolCall {
            name: "read_file".to_string(),
            args: r#"{"path": "/tmp/test.txt"}"#.to_string(),
        };

        let domain = proto_tool_call_to_domain(proto_tc);
        assert_eq!(domain.name, "read_file");
        assert_eq!(domain.args["path"], "/tmp/test.txt");
    }

    #[test]
    fn test_proto_tool_call_with_invalid_json() {
        let proto_tc = proto::ToolCall {
            name: "test".to_string(),
            args: "not json".to_string(),
        };

        let domain = proto_tool_call_to_domain(proto_tc);
        assert_eq!(domain.name, "test");
        assert!(domain.args.is_null());
    }

    #[test]
    fn test_proto_tool_result_to_domain() {
        let proto_tr = proto::ToolResult {
            name: "exec".to_string(),
            output: "hello world".to_string(),
            exit_code: 0,
        };

        let domain = proto_tool_result_to_domain(proto_tr);
        assert_eq!(domain.name, "exec");
        assert_eq!(domain.output, "hello world");
        assert_eq!(domain.exit_code, 0);
    }

    #[test]
    fn test_proto_step_to_domain() {
        let proto_step = proto::Step {
            index: 1,
            step_type: "thinking".to_string(),
            content: "I should read the file".to_string(),
        };

        let domain = proto_step_to_domain(proto_step);
        assert_eq!(domain.index, 1);
        assert!(matches!(domain.step_type, crate::session::StepType::Thinking));
        assert_eq!(domain.content, "I should read the file");
    }

    #[test]
    fn test_proto_step_unknown_type_defaults_to_text() {
        let proto_step = proto::Step {
            index: 0,
            step_type: "unknown".to_string(),
            content: "content".to_string(),
        };

        let domain = proto_step_to_domain(proto_step);
        assert!(matches!(domain.step_type, crate::session::StepType::Text));
    }

    #[test]
    fn test_proto_generate_response_to_result() {
        let response = proto::GenerateResponse {
            text: "Hello!".to_string(),
            usage: Some(proto::TokenUsage {
                prompt_tokens: 10,
                completion_tokens: 5,
                total_tokens: 15,
            }),
            tool_calls: vec![],
            tool_results: vec![],
            steps: vec![],
        };

        let result = proto_generate_response_to_result(response);
        assert_eq!(result.text, "Hello!");
        assert_eq!(result.usage.total_tokens, 15);
    }

    #[test]
    fn test_proto_generate_response_without_usage() {
        let response = proto::GenerateResponse {
            text: "test".to_string(),
            usage: None,
            tool_calls: vec![],
            tool_results: vec![],
            steps: vec![],
        };

        let result = proto_generate_response_to_result(response);
        assert_eq!(result.usage.total_tokens, 0);
    }

    #[test]
    fn test_proto_stream_chunk_text_delta() {
        let chunk = proto::StreamChunk {
            chunk: Some(proto::stream_chunk::Chunk::TextDelta("hello".to_string())),
        };

        let domain = proto_stream_chunk_to_domain(chunk).unwrap();
        assert!(matches!(domain, StreamChunk::TextDelta(ref s) if s == "hello"));
    }

    #[test]
    fn test_proto_stream_chunk_tool_call() {
        let chunk = proto::StreamChunk {
            chunk: Some(proto::stream_chunk::Chunk::ToolCall(proto::ToolCall {
                name: "read".to_string(),
                args: "{}".to_string(),
            })),
        };

        let domain = proto_stream_chunk_to_domain(chunk).unwrap();
        assert!(matches!(domain, StreamChunk::ToolCall { ref name, .. } if name == "read"));
    }

    #[test]
    fn test_proto_stream_chunk_none() {
        let chunk = proto::StreamChunk { chunk: None };

        assert!(proto_stream_chunk_to_domain(chunk).is_none());
    }

    #[tokio::test]
    async fn test_connect_nonexistent_socket() {
        let result = AgentClient::connect(Path::new("/tmp/nonexistent-a3s-test.sock")).await;
        assert!(result.is_err());
    }
}
